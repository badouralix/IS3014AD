\chapter{Génération des tests}

\section{Implémentation}

On adopte la stratégie générale suivante pour générer les tests associés à un
critère donné :

\begin{itemize}
	\item générer un ensemble de chemins par lesquels on veut passer --- en
	fonction du critère, on voudra passer par \textbf{tous} les chemins, ou
	par \textbf{au moins} un chemin
	\item pour chaque chemin, faire une exécution symbolique --- on notera
	l'utilisation de symboles \textbf{uniques} associés à chaque variable
	explicite ou implicite (~\textit{ie.} les registres \texttt{\_reg}, qui
	enregistrent les calculent intermédiaires~)
	\item chaque exécution symbolique fournit des contraintes entre les
	symboles : donner ces contraintes au solveur Z3
	\item obtenir un test associé à un chemin si le problème est satisfiable
\end{itemize}

\bigskip

L'exécution symbolique à partir d'un chemin sur le CFG ainsi que la résolution
du problème de contraintes sont effectuées dans le fichier
\texttt{src/tests/solver.py}.

\bigskip

La génération des chemins est propre à chaque critère et est détaillée
ci-dessous. Sauf explicitement dit, lorsque l'on dira que l'on génére tous les
chemins entre deux nodes, on sous-entendra \textit{tous les chemins simples}.
Il s'agit d'un choix tout à fait discutable, mais étant donné l'indécitabilité
du problème de la génération des tests, il faut de toute manière se fixer une
limite raisonnable.

\subsection{Toutes les affectations}

Le critère \textit{toutes les affectations} est un critère sur les nodes du
CFG. Pour chaque node \texttt{SAssign}, on va générer tous les chemins jusqu'à
ce node, en partant du node \texttt{START}.

On obtient un test pour un node lorsque l'on trouve au moins un chemin généré
faisable.

\subsection{Toutes les décisions}

Le critère \textit{toutes les décisions} est un critère sur les edges du CFG.
On souhaite passer par chaque edge sortant d'un node de type \texttt{SIf} ou
\texttt{SWhile}. On peut donc se ramener à un critère d'accessibilité au node
de décision (~\texttt{SIf} ou \texttt{SWhile}~). On génère tous les chemins
jusqu'au node, puis pour chaque chemin, on génère deux chemins : un chemin où
l'on a rajouté l'edge associé à la décision \texttt{true}, un autre chemin où
l'on a rajouté l'edge associé à la décision \texttt{false}.

On obtient un test pour un edge lorsque l'on trouve au moins un chemin généré
faisable.

\subsection{Tous les $k$-chemins}

Le critère \textit{tous les $k$-chemins} est un critère sur les chemins du CFG.
On utilise donc directement le générateur de \texttt{k-path} du fichier
\texttt{src/cfgraph/utils.py}. Il faut trouver un test pour chaque chemin. Si
le solveur ne trouve pas de test admissible, le chemin n'est pas faisable.

\subsection{Toutes les $i$-boucles}

Le critère \textit{toutes les $i$-boucles} est un critère sur les chemins du CFG.
On utilise donc directement le générateur de \texttt{i-loop} du fichier
\texttt{src/cfgraph/utils.py}. Il faut trouver un test pour chaque chemin. Si
le solveur ne trouve pas de test admissible, le chemin n'est pas faisable.

\subsection{Toutes les définitions}

Le critère \textit{toutes les définitions} est un critère sur les nodes de type
\textit{SAssign}. Pour chaque node \texttt{ndef}, on cherche les utilisations
associées \texttt{nref} (~\textit{ie.} sans redéfinition intermédiaire.~) On
forme ainsi, pour chaque node \texttt{ndef}, un ensemble de paires de nodes
\texttt{(ndef, nref)}. Pour chaque paire, on génère tous les chemins entre
\texttt{START} et \texttt{ndef} et entre \texttt{ndef} et \texttt{nref}. On
concatène deux sous-chemins pour obtenir un chemin pour la paire
\texttt{(ndef, nref)}.

On obtient un test pour un node \texttt{ndef} lorsque l'on trouve au moins un
node \texttt{nref} associé et un chemin, associé à la paire
\texttt{(ndef, nref)}, faisable.

\subsection{Toutes les utilisations}

Le critère \textit{toutes les utilisations} est un critère sur les paires de
nodes entre la définition d'une variable et son utilisation (~sans redéfinition
intermédiaire.~) Pour chaque paire de nodes \texttt{(ndef, nref)}, on génère
tous les chemins entre \texttt{START} et \texttt{ndef} et entre \texttt{ndef}
et \texttt{nref}. On concatène deux sous-chemins pour obtenir un chemin pour la
paire \texttt{(ndef, nref)}.

On obtient un test pour une paire \texttt{(ndef, nref)} lorsque l'on trouve au
moins un chemin généré faisable.

\subsection{Tous les DU-chemins}

Le critère \textit{tous les DU-chemins} est assez similaire au critère
\textit{toutes les utilisations}. De la même manière, on génère un ensemble de
chemins pour une paire \texttt{(ndef, nref)} donnée.

La différence étant qu'il faut trouver un test pour chaque chemin. Et si le
solveur ne trouve pas de test admissible, le chemin n'est pas faisable.

\section{Résultats}
